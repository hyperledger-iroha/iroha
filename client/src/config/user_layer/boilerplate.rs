//! Code to be generated by a proc macro in future

use std::{fs::File, io::Read, path::Path};

use eyre::{eyre, Context};
use iroha_config::base::{
    Emitter, FromEnvDefaultFallback, Merge, MissingFieldError, UnwrapPartial, UnwrapPartialResult,
    UserDuration, UserField,
};
use iroha_crypto::{PrivateKey, PublicKey};
use iroha_data_model::{account::AccountId, ChainId};
use serde::Deserialize;

use crate::config::{
    user_layer::{Account, Api, OnlyHttpUrl, Root, Transaction},
    BasicAuth, DEFAULT_ADD_TRANSACTION_NONCE, DEFAULT_TRANSACTION_STATUS_TIMEOUT,
    DEFAULT_TRANSACTION_TIME_TO_LIVE,
};

#[derive(Debug, Clone, Deserialize, Eq, PartialEq, Default, Merge)]
#[serde(deny_unknown_fields, default)]
pub struct RootPartial {
    pub chain_id: UserField<ChainId>,
    pub account: AccountPartial,
    pub api: ApiPartial,
    pub transaction: TransactionPartial,
}

impl RootPartial {
    pub fn new() -> Self {
        // TODO: gen with macro
        Default::default()
    }

    pub fn from_toml(path: impl AsRef<Path>) -> eyre::Result<Self> {
        let contents = {
            let mut contents = String::new();
            File::open(path.as_ref())
                .wrap_err_with(|| {
                    eyre!("cannot open file at location `{}`", path.as_ref().display())
                })?
                .read_to_string(&mut contents)?;
            contents
        };
        let layer: Self = toml::from_str(&contents).wrap_err("failed to parse toml")?;
        Ok(layer)
    }

    pub fn merge(mut self, other: Self) -> Self {
        Merge::merge(&mut self, other);
        self
    }
}

// FIXME: should config be read from ENV?
impl FromEnvDefaultFallback for RootPartial {}

impl UnwrapPartial for RootPartial {
    type Output = Root;

    fn unwrap_partial(self) -> UnwrapPartialResult<Self::Output> {
        let mut emitter = Emitter::new();

        if self.chain_id.is_none() {
            emitter.emit_missing_field("chain_id");
        }
        let account = emitter.try_unwrap_partial(self.account);
        let api = emitter.try_unwrap_partial(self.api);
        let transaction = emitter.try_unwrap_partial(self.transaction);

        emitter.finish()?;

        Ok(Root {
            chain_id: self.chain_id.get().unwrap(),
            account: account.unwrap(),
            api: api.unwrap(),
            transaction: transaction.unwrap(),
        })
    }
}

#[derive(Debug, Clone, Deserialize, Eq, PartialEq, Default, Merge)]
#[serde(deny_unknown_fields, default)]
pub struct ApiPartial {
    pub torii_url: UserField<OnlyHttpUrl>,
    pub basic_auth: UserField<BasicAuth>,
}

impl UnwrapPartial for ApiPartial {
    type Output = Api;

    fn unwrap_partial(self) -> UnwrapPartialResult<Self::Output> {
        Ok(Api {
            torii_url: self
                .torii_url
                .get()
                .ok_or_else(|| MissingFieldError::new("api.torii_url"))?,
            basic_auth: self.basic_auth.get(),
        })
    }
}

#[derive(Debug, Clone, Deserialize, Eq, PartialEq, Default, Merge)]
#[serde(deny_unknown_fields, default)]
pub struct AccountPartial {
    pub id: UserField<AccountId>,
    pub public_key: UserField<PublicKey>,
    pub private_key: UserField<PrivateKey>,
}

impl UnwrapPartial for AccountPartial {
    type Output = Account;

    fn unwrap_partial(self) -> UnwrapPartialResult<Self::Output> {
        let mut emitter = Emitter::new();

        if self.id.is_none() {
            emitter.emit_missing_field("account.id");
        }
        if self.public_key.is_none() {
            emitter.emit_missing_field("account.public_key");
        }
        if self.private_key.is_none() {
            emitter.emit_missing_field("account.private_key");
        }

        emitter.finish()?;

        Ok(Account {
            id: self.id.get().unwrap(),
            public_key: self.public_key.get().unwrap(),
            private_key: self.private_key.get().unwrap(),
        })
    }
}

#[derive(Debug, Clone, Deserialize, Eq, PartialEq, Default, Merge)]
#[serde(deny_unknown_fields, default)]
pub struct TransactionPartial {
    pub time_to_live: UserField<UserDuration>,
    pub status_timeout: UserField<UserDuration>,
    pub add_nonce: UserField<bool>,
}

impl UnwrapPartial for TransactionPartial {
    type Output = Transaction;

    fn unwrap_partial(self) -> UnwrapPartialResult<Self::Output> {
        Ok(Transaction {
            time_to_live: self
                .time_to_live
                .get()
                .map_or(DEFAULT_TRANSACTION_TIME_TO_LIVE, UserDuration::get),
            status_timeout: self
                .status_timeout
                .get()
                .map_or(DEFAULT_TRANSACTION_STATUS_TIMEOUT, UserDuration::get),
            add_nonce: self
                .add_nonce
                .get()
                .unwrap_or(DEFAULT_ADD_TRANSACTION_NONCE),
        })
    }
}
