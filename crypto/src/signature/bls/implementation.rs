use std::{hash::Hash, marker::PhantomData};

/// Implements
/// <https://eprint.iacr.org/2018/483> and
/// <https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html>
use amcl_wrapper::{
    field_elem::FieldElement, group_elem::GroupElement, group_elem_g1::G1, group_elem_g2::G2,
};
use sha2::Sha256;

pub(super) const MESSAGE_CONTEXT: &[u8; 20] = b"for signing messages";

// it is not unused? Why am I getting the unused lint here?
#[allow(dead_code)]
const PUBLICKEY_CONTEXT: &[u8; 47] = b"for signing public keys for proof of possession";

use super::PRIVATE_KEY_SIZE;
use crate::{
    Algorithm, ConstVec, Error, KeyGenOption, PrivateKey as IrohaPrivateKey,
    PublicKey as IrohaPublicKey,
};

/// This is a simple alias so the consumer can just use `PrivateKey::random`() to generate a new one
/// instead of wrapping it as a private field
pub type PrivateKey = FieldElement;

pub trait BlsConfiguration {
    const ALGORITHM: Algorithm;
    const PK_SIZE: usize;
    const SIG_SIZE: usize;
    type Generator: GroupElement + Eq + PartialEq + Hash;
    type SignatureGroup: GroupElement + Eq + PartialEq + Hash;
    fn ate_2_pairing_is_one(
        g: &Self::Generator,
        sig: &Self::SignatureGroup,
        pk: &Self::Generator,
        hash: &Self::SignatureGroup,
    ) -> bool;
    fn set_pairs(p: &(Self::Generator, Self::SignatureGroup)) -> (&G1, &G2);

    /// Creates a new BLS key pair
    fn generate(g: &Self::Generator) -> (PublicKey<Self>, PrivateKey) {
        let sk = PrivateKey::random();
        let pk = PublicKey::new(&sk, g);
        (pk, sk)
    }

    fn hash_to_point<A: AsRef<[u8]>>(v: A, ctx: &[u8]) -> Self::SignatureGroup {
        let mut value = Vec::new();
        value.extend_from_slice(ctx);
        value.extend_from_slice(v.as_ref());
        Self::SignatureGroup::from_msg_hash(value.as_slice())
    }

    fn hash_msg<A: AsRef<[u8]>>(
        message: A,
        context: Option<&'static [u8]>,
    ) -> Self::SignatureGroup {
        let ctx: &[u8] = context.unwrap_or(MESSAGE_CONTEXT);
        Self::hash_to_point(message, ctx)
    }

    fn hash_key(pk: &PublicKey<Self>, context: Option<&'static [u8]>) -> Self::SignatureGroup {
        let ctx: &[u8] = context.unwrap_or(PUBLICKEY_CONTEXT);
        Self::hash_to_point(pk.to_bytes(), ctx)
    }
}

pub struct PublicKey<C: BlsConfiguration + ?Sized>(C::Generator);

impl<C: BlsConfiguration + ?Sized> PublicKey<C> {
    pub fn new(sk: &PrivateKey, g: &C::Generator) -> Self {
        Self(g.scalar_mul_const_time(sk))

        // Self(g * sk)
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        self.0.to_bytes(false)
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<Self, Error> {
        Ok(Self(
            C::Generator::from_bytes(bytes).map_err(|e| Error::Parse(format!("{e:?}")))?,
        ))
    }
}

/// Signature over a message. One gotcha for BLS signatures
/// is the need to mitigate rogue key attacks. There are two methods to achieve
/// this: compute additional work to make each message distinct
/// in a signature for each `PublicKey` or
/// use `ProofOfPossession`. `Signature` and `ProofOfPossession` MUST
/// use domain separation values that are different
/// to avoid certain types of attacks and make `Signature`
/// distinct from `ProofOfPossession`. If `ProofOfPossession`
/// and `Signature` use the same value for `context` they are effectively the same.
/// Don't do this. You have been warned.
///
/// To make messages distinct, use `new_with_rk_mitigation`. If using
/// proof of possession mitigation, use `new`.
#[derive(Debug, Clone)]
pub struct Signature<C: BlsConfiguration + ?Sized>(C::SignatureGroup);

impl<C: BlsConfiguration + ?Sized> Signature<C> {
    pub fn new<A: AsRef<[u8]>>(
        message: A,
        context: Option<&'static [u8]>,
        sk: &PrivateKey,
    ) -> Self {
        Self(C::hash_msg(message, context).scalar_mul_const_time(sk))
    }

    // Verify a signature generated by `new`
    pub fn verify<A: AsRef<[u8]>>(
        &self,
        message: A,
        context: Option<&'static [u8]>,
        pk: &PublicKey<C>,
        g: &C::Generator,
    ) -> bool {
        let hash = C::hash_msg(message, context);
        C::ate_2_pairing_is_one(g, &self.0, &pk.0, &hash)
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        self.0.to_bytes(false)
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<Self, Error> {
        Ok(Signature(
            C::SignatureGroup::from_bytes(bytes).map_err(|e| Error::Parse(format!("{e:?}")))?,
        ))
    }
}

pub struct BlsImpl<C: BlsConfiguration + ?Sized>(PhantomData<C>);

impl<C: BlsConfiguration + ?Sized> BlsImpl<C> {
    fn parse_public_key(pk: &IrohaPublicKey) -> Result<PublicKey<C>, Error> {
        assert_eq!(pk.digest_function, C::ALGORITHM);
        PublicKey::from_bytes(&pk.payload)
            .map_err(|e| Error::Parse(format!("Failed to parse public key: {e}")))
    }

    fn parse_private_key(sk: &IrohaPrivateKey) -> Result<PrivateKey, Error> {
        assert_eq!(sk.digest_function, C::ALGORITHM);
        PrivateKey::from_bytes(&sk.payload)
            .map_err(|e| Error::Parse(format!("Failed to parse private key: {e}")))
    }

    // the names are from an RFC, not a good idea to change them
    #[allow(clippy::similar_names)]
    pub fn keypair(
        options: Option<KeyGenOption>,
    ) -> Result<(IrohaPublicKey, IrohaPrivateKey), Error> {
        let (public_key, private_key) = match options {
            Some(option) => match option {
                // Follows https://datatracker.ietf.org/doc/draft-irtf-cfrg-bls-signature/?include_text=1
                KeyGenOption::UseSeed(ref seed) => {
                    let salt = b"BLS-SIG-KEYGEN-SALT-";
                    let info = [0u8, PRIVATE_KEY_SIZE.try_into().unwrap()]; // key_info || I2OSP(L, 2)
                    let mut ikm = vec![0u8; seed.len() + 1];
                    ikm[..seed.len()].copy_from_slice(seed); // IKM || I2OSP(0, 1)
                    let mut okm = [0u8; PRIVATE_KEY_SIZE];
                    let h = hkdf::Hkdf::<Sha256>::new(Some(&salt[..]), &ikm);
                    h.expand(&info[..], &mut okm).map_err(|err| {
                        Error::KeyGen(format!("Failed to generate keypair: {err}"))
                    })?;
                    let private_key: PrivateKey = PrivateKey::from(&okm);
                    (
                        PublicKey::new(&private_key, &C::Generator::generator()),
                        private_key,
                    )
                }
                KeyGenOption::FromPrivateKey(ref key) => {
                    let private_key = Self::parse_private_key(key)?;
                    (
                        PublicKey::new(&private_key, &C::Generator::generator()),
                        private_key,
                    )
                }
            },
            None => C::generate(&C::Generator::generator()),
        };
        Ok((
            IrohaPublicKey {
                digest_function: C::ALGORITHM,
                payload: ConstVec::new(public_key.to_bytes()),
            },
            IrohaPrivateKey {
                digest_function: C::ALGORITHM,
                payload: ConstVec::new(private_key.to_bytes()),
            },
        ))
    }

    pub fn sign(message: &[u8], sk: &IrohaPrivateKey) -> Result<Vec<u8>, Error> {
        let sk = Self::parse_private_key(sk)?;

        Ok(Signature::<C>::new(message, None, &sk).to_bytes())
    }

    pub fn verify(message: &[u8], signature: &[u8], pk: &IrohaPublicKey) -> Result<bool, Error> {
        let pk = Self::parse_public_key(pk)?;

        Ok(Signature::<C>::from_bytes(signature)
            .map_err(|_| Error::Parse("Failed to parse signature.".to_string()))?
            .verify(message, None, &pk, &C::Generator::generator()))
    }
}
