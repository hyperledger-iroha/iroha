#![allow(trivial_casts)]

//! Logic related to the conversion of IR types to equivalent robust C types. Types that are mapped into
//! one of the predefined [`Ir`] types will be provided an automatic implementation of traits in this module.
//!
//! Traits in this module mainly exist to bridge the gap between IR and C type equivalents. User should
//! only implement these traits if none of the predefined IR types provide an adequate mapping.
use alloc::{boxed::Box, vec::Vec};
use core::{mem::ManuallyDrop, ptr::addr_of_mut};

use crate::{
    ir::{External, Ir, Opaque, Robust, Transmute, Transparent},
    slice::{OutBoxedSlice, SliceMut, SliceRef},
    Extern, FfiConvert, FfiOutPtr, FfiOutPtrRead, FfiOutPtrWrite, FfiReturn, FfiType,
    FfiWrapperType, LocalRef, LocalSlice, ReprC, Result, WrapperTypeOf,
};

/// A type that can be converted into a C type.
///
/// If a type also implements [`Ir`], i.e. has a defined internal representation, a blanket
/// implementation of [`FfiType`] will be provided.
pub trait CType<S> {
    /// C type current type can be converted into
    type ReprC: ReprC;
}

/// The trait facilitates conversion of rust types to/from `ReprC` types.
///
/// If a type also implements [`Ir`], i.e. has a defined internal representation, a blanket
/// implementation of [`FfiConvert`] will be provided.
pub trait CTypeConvert<'itm, S, C: ReprC>: Sized {
    /// Type into which state can be stored during conversion from [`Self`]. Useful for
    /// returning owning heap allocated types or non-owning types that are not transmutable.
    /// Serves similar purpose as does context in a closure
    type RustStore: Default;

    /// Type into which state can be stored during conversion into [`Self`]. Useful for
    /// returning non-owning types that are not transmutable. Serves similar purpose as
    /// does context in a closure
    type FfiStore: Default;

    /// Perform the conversion from [`Self`] into `[Self::ReprC]`
    fn into_repr_c(self, store: &'itm mut Self::RustStore) -> C;

    /// Perform the conversion from [`Self::ReprC`] into `[Self]`
    ///
    /// # Errors
    ///
    /// Check [`FfiReturn`]
    ///
    /// # Safety
    ///
    /// All conversions from a pointer must ensure pointer validity beforehand
    unsafe fn try_from_repr_c(source: C, store: &'itm mut Self::FfiStore) -> Result<Self>;
}

/// The trait is used to replace the type in the wrapper function generated by [`ffi_import`].
///
/// Most notably, the necessity to replace the output type for a wrapper function arises when:
/// - the wrapper function returns a reference that uses store during conversion (i.e. that are cloned)
/// - the wrapper function takes/return an opaque type reference
///
/// If a type also implements [`Ir`], i.e. has a defined internal representation, a blanket
/// implementation of [`FfiWrapperType`] will be provided.
pub trait CWrapperType<S> {
    /// Type used instead of the input type in the wrapper function generated by `ffi_import`
    type InputType;
    /// Type used instead of the output type in the wrapper function generated by `ffi_import`
    type ReturnType;
}

/// Facilitates the use of [`Self`] as out-pointer.
///
/// If a type also implements [`Ir`], i.e. has a defined internal representation, a blanket
/// implementation of [`COutPtr`] will be provided.
pub trait COutPtr<S>: CType<S> {
    /// Out-pointer type
    type OutPtr: ReprC;
}

/// Facilitates writing [`Self`] into [`Self::OutPtr`].
///
/// If a type also implements [`Ir`], i.e. has a defined internal representation, a blanket
/// implementation of [`COutPtr`] will be provided.
pub trait COutPtrWrite<S>: COutPtr<S> {
    /// Write the given rust value into the corresponding out-pointer
    ///
    /// # Safety
    ///
    /// [`*mut Self::OutPtr`] must be valid
    unsafe fn write_out(self, out_ptr: *mut <Self as COutPtr<S>>::OutPtr);
}

/// Facilitates reading from [`Self::OutPtr`] out-pointer.
///
/// If a type also implements [`Ir`], i.e. has a defined internal representation, a blanket
/// implementation of [`COutPtr`] will be provided.
pub trait COutPtrRead<S>: COutPtr<S> + Sized {
    /// Read a rust value from the corresponding out-pointer
    ///
    /// # Errors
    ///
    /// Check [`CConvert::try_from_repr_c`]
    ///
    /// # Safety
    ///
    /// Check [`CConvert::try_from_repr_c`]
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self>;
}

/// Marker trait indicating that [`CTypeConvert::into_repr_c`] and [`CTypeConvert::try_from_repr_c`] don't
/// return a reference to the store. This is useful to determine which(and how) types can be
/// returned from an FFI function considering that, after return, local context is destroyed
///
/// # Example
///
/// 1. `&[u8]` implements [`NonLocal`]
/// This type will be converted to [`SliceRef<u8>`] and during conversion will not make use
/// of the store (in any direction). The corresponding out-pointer will be `*mut SliceRef<u8>`
///
/// 2. `&[Opaque<T>]` doesn't implement [`NonLocal`]
/// This type will be converted to [`SliceRef<*const T>`] and during conversion will use the
/// local store `Vec<*const T>`. The corresponding out-pointer will be `*mut OutBoxedSlice<*const T>`.
///
/// 3. `&(u32, u32)`
/// This type will be converted to `*const FfiTuple2<u32, u32>` and during conversion will use the
/// local store `FfiTuple<u32, u32>`. The corresponding out-pointer will be `*mut FfiTuple2<u32, u32>`
///
/// # Safety
///
/// Type must not make use of the store during conversion into [`CType::ReprC`] via [`CTypeConvert::into_repr_c`] or [`CTypeConvert::try_from_repr_c`]
pub unsafe trait NonLocal<S>: COutPtr<S> {}

/// Type that cannot be transmuted into a [`ReprC`] type is therefore cloned when
/// converting the likes of `&Self` or `&[Self]` into an FFI-compatible representation
pub trait Cloned {}

impl<R: Ir> Cloned for &R where R::Type: Cloned {}
impl<R> Cloned for Box<R> {}
impl<R> Cloned for &[R] {}
impl<R> Cloned for Vec<R> {}
// TODO: This means there is unnecesary clone?
impl<const N: usize> Cloned for [Opaque; N] {}
impl<R: Ir, const N: usize> Cloned for [R; N] where R::Type: Cloned {}

impl<'itm, R: NonLocal<S> + 'itm, S: Cloned> CType<&'itm S> for LocalRef<'itm, R>
where
    &'itm R: CType<&'itm S>,
{
    type ReprC = <&'itm R as CType<&'itm S>>::ReprC;
}
impl<'itm, R: NonLocal<S> + 'itm, S: Cloned> COutPtr<&'itm S> for LocalRef<'itm, R>
where
    &'itm R: COutPtr<&'itm S>,
{
    type OutPtr = <&'itm R as COutPtr<&'itm S>>::OutPtr;
}

impl<'itm, R: NonLocal<S> + 'itm, S: Cloned> CType<&'itm [S]> for LocalSlice<'itm, R>
where
    &'itm [R]: CType<&'itm [S]>,
{
    type ReprC = <&'itm [R] as CType<&'itm [S]>>::ReprC;
}
impl<'itm, R: NonLocal<S> + 'itm, S: Cloned> COutPtr<&'itm [S]> for LocalSlice<'itm, R>
where
    &'itm [R]: COutPtr<&'itm [S]>,
{
    type OutPtr = <&'itm [R] as COutPtr<&'itm [S]>>::OutPtr;
}

impl<R, S> CType<Vec<S>> for LocalSlice<'_, R>
where
    Vec<R>: CType<Vec<S>>,
{
    type ReprC = <Vec<R> as CType<Vec<S>>>::ReprC;
}
impl<R, S> COutPtr<Vec<S>> for LocalSlice<'_, R>
where
    Vec<R>: COutPtr<Vec<S>>,
{
    type OutPtr = <Vec<R> as COutPtr<Vec<S>>>::OutPtr;
}

// NOTE: `CType` cannot be implemented for `&mut T`
impl<R: CType<S>, S: Cloned> CType<&S> for &R {
    type ReprC = *const R::ReprC;
}
impl<'itm, R: CTypeConvert<'itm, S, C> + Clone, S: Cloned, C: ReprC>
    CTypeConvert<'itm, &'itm S, *const C> for &'itm R
{
    type RustStore = (Option<C>, R::RustStore);
    type FfiStore = (Option<R>, R::FfiStore);

    fn into_repr_c(self, store: &'itm mut Self::RustStore) -> *const C {
        store.0.insert(self.clone().into_repr_c(&mut store.1))
    }

    unsafe fn try_from_repr_c(source: *const C, store: &'itm mut Self::FfiStore) -> Result<Self> {
        if source.as_ref().is_none() {
            return Err(FfiReturn::ArgIsNull);
        }

        Ok(store.0.insert(
            R::try_from_repr_c(source.read(), &mut store.1)
                .map(ManuallyDrop::new)
                .map(|item| (*item).clone())?,
        ))
    }
}

impl<'itm, R: CWrapperType<S>, S: Cloned> CWrapperType<&'itm S> for &'itm R {
    type InputType = &'itm R::InputType;
    type ReturnType = LocalRef<'itm, R::ReturnType>;
}
impl<R: NonLocal<S>, S: Cloned> COutPtr<&S> for &R {
    type OutPtr = R::ReprC;
}
impl<'itm, R: NonLocal<S> + CTypeConvert<'itm, S, R::ReprC> + Clone, S: Cloned + 'itm>
    COutPtrWrite<&'itm S> for &'itm R
{
    unsafe fn write_out(self, out_ptr: *mut R::ReprC) {
        let mut store = Default::default();
        // NOTE: Bypasses the erroneous lifetime check.
        // Correct as long as `R::into_repr_c` doesn't return a reference to the store (`R: NonLocal`)
        let store_borrow = &mut *addr_of_mut!(store);
        CTypeConvert::<&S, _>::into_repr_c(self, store_borrow);

        // NOTE: None value indicates a bug in the implementation
        out_ptr.write(store.0.expect("Store must be initialized"));
    }
}
impl<'itm, R: NonLocal<S> + CTypeConvert<'itm, S, R::ReprC> + Clone + 'itm, S: Cloned>
    COutPtrRead<&'itm S> for LocalRef<'itm, R>
{
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self> {
        let mut store = Default::default();
        // NOTE: Bypasses the erroneous lifetime check.
        // Correct as long as `R::try_from_repr_c` doesn't return a reference to the store (`R: NonLocal`)
        let store_borrow = &mut *addr_of_mut!(store);
        let item = R::try_from_repr_c(out_ptr, store_borrow)?;
        Ok(Self(item, core::marker::PhantomData))
    }
}

impl<R: CType<S>, S: Cloned> CType<Box<S>> for Box<R> {
    type ReprC = *mut R::ReprC;
}
impl<'itm, R: CTypeConvert<'itm, S, C> + Clone, S: Cloned, C: ReprC>
    CTypeConvert<'itm, Box<S>, *mut C> for Box<R>
{
    type RustStore = (Option<C>, R::RustStore);
    type FfiStore = R::FfiStore;

    fn into_repr_c(self, store: &'itm mut Self::RustStore) -> *mut C {
        store.0.insert((*self).into_repr_c(&mut store.1))
    }
    unsafe fn try_from_repr_c(source: *mut C, store: &'itm mut Self::FfiStore) -> Result<Self> {
        if source.as_mut().is_none() {
            return Err(FfiReturn::ArgIsNull);
        }

        R::try_from_repr_c(source.read(), store)
            .map(ManuallyDrop::new)
            .map(|item| (*item).clone())
            .map(Box::new)
    }
}

impl<R: CWrapperType<S>, S: Cloned> CWrapperType<Box<S>> for Box<R> {
    type InputType = Box<R::InputType>;
    type ReturnType = Box<R::ReturnType>;
}
impl<R: NonLocal<S>, S: Cloned> COutPtr<Box<S>> for Box<R> {
    type OutPtr = R::ReprC;
}
impl<'itm, R: NonLocal<S> + CTypeConvert<'itm, S, R::ReprC> + Clone + 'itm, S: Cloned + 'itm>
    COutPtrWrite<Box<S>> for Box<R>
{
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        let mut store = <(Option<R::ReprC>, R::RustStore)>::default();
        // NOTE: Bypasses the erroneous lifetime check.
        // Correct as long as `R::into_repr_c` doesn't return a reference to the store (`R: NonLocal`)
        let store_borrow = &mut *addr_of_mut!(store);
        CTypeConvert::<Box<S>, _>::into_repr_c(self, store_borrow);

        // NOTE: None value indicates a bug in the implementation
        #[allow(clippy::expect_used)]
        out_ptr.write(store.0.expect("Store must be initialized"));
    }
}
impl<'itm, R: NonLocal<S> + CTypeConvert<'itm, S, R::ReprC> + Clone + 'itm, S: Cloned + 'itm>
    COutPtrRead<Box<S>> for Box<R>
{
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self> {
        let mut store = Default::default();
        // NOTE: Bypasses the erroneous lifetime check.
        // Correct as long as `R::try_from_repr_c` doesn't return a reference to the store (`R: NonLocal`)
        let store_borrow = &mut *addr_of_mut!(store);
        let item = R::try_from_repr_c(out_ptr, store_borrow)?;
        Ok(Box::new(item))
    }
}

// NOTE: `CType` cannot be implemented for `&mut [T]`
impl<R: CType<S>, S: Cloned> CType<&[S]> for &[R] {
    type ReprC = SliceRef<R::ReprC>;
}
impl<'slice, R: CTypeConvert<'slice, S, C> + Clone, S: Cloned, C: ReprC>
    CTypeConvert<'slice, &'slice [S], SliceRef<C>> for &'slice [R]
{
    type RustStore = (Vec<C>, Vec<R::RustStore>);
    type FfiStore = (Vec<R>, Vec<R::FfiStore>);

    fn into_repr_c(self, store: &'slice mut Self::RustStore) -> SliceRef<C> {
        let slice = self.to_vec();

        store.1 = core::iter::repeat_with(Default::default)
            .take(slice.len())
            .collect();

        store.0 = slice
            .into_iter()
            .zip(&mut store.1)
            .map(|(item, substore)| item.into_repr_c(substore))
            .collect();

        SliceRef::from_slice(Some(&store.0))
    }

    unsafe fn try_from_repr_c(
        source: SliceRef<C>,
        store: &'slice mut Self::FfiStore,
    ) -> Result<Self> {
        store.1 = core::iter::repeat_with(Default::default)
            .take(source.len())
            .collect();

        let source: Vec<ManuallyDrop<R>> = source
            .into_rust()
            .ok_or(FfiReturn::ArgIsNull)?
            .iter()
            .zip(&mut store.1)
            .map(|(&item, substore)| R::try_from_repr_c(item, substore).map(ManuallyDrop::new))
            .collect::<core::result::Result<_, _>>()?;

        store.0 = source
            .iter()
            .cloned()
            .map(ManuallyDrop::into_inner)
            .collect();

        Ok(&store.0)
    }
}

impl<'itm, R: CWrapperType<S>, S: Cloned> CWrapperType<&'itm [S]> for &'itm [R] {
    type InputType = &'itm [R::InputType];
    type ReturnType = LocalSlice<'itm, R::ReturnType>;
}
impl<R: NonLocal<S>, S: Cloned> COutPtr<&[S]> for &[R] {
    type OutPtr = OutBoxedSlice<R::ReprC>;
}
impl<'itm, R: NonLocal<S> + CTypeConvert<'itm, S, R::ReprC> + Clone, S: Cloned>
    COutPtrWrite<&'itm [S]> for &'itm [R]
{
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        let mut store = <(Vec<R::ReprC>, Vec<R::RustStore>)>::default();
        // NOTE: Bypasses the erroneous lifetime check.
        // Correct as long as `R::into_repr_c` doesn't return a reference to the store (`R: NonLocal`)
        let store_borrow = &mut *addr_of_mut!(store);
        CTypeConvert::<&[S], _>::into_repr_c(self, store_borrow);
        out_ptr.write(OutBoxedSlice::from_vec(Some(store.0)));
    }
}
impl<'itm, R: NonLocal<S> + CTypeConvert<'itm, S, R::ReprC> + Clone + 'itm, S: Cloned + 'itm>
    COutPtrRead<&'itm [S]> for LocalSlice<'itm, R>
{
    unsafe fn try_read_out(out_ptr: OutBoxedSlice<R::ReprC>) -> Result<Self> {
        let slice = SliceRef::from_raw_parts(out_ptr.as_mut_ptr(), out_ptr.len());

        let mut store = <(Vec<R>, Vec<R::FfiStore>)>::default();
        // NOTE: Bypasses the erroneous lifetime check.
        // Correct as long as `R::try_from_repr_c` doesn't return a reference to the store (`R: NonLocal`)
        let store_borrow = &mut *addr_of_mut!(store);
        let res = <&[R]>::try_from_repr_c(slice, store_borrow);

        if !out_ptr.deallocate() {
            return Err(FfiReturn::TrapRepresentation);
        }

        res?;
        Ok(Self(store.0, core::marker::PhantomData))
    }
}

impl<R: CType<S>, S: Cloned> CType<Vec<S>> for Vec<R> {
    type ReprC = SliceMut<R::ReprC>;
}
impl<'itm, R: CTypeConvert<'itm, S, C> + Clone, S: Cloned, C: ReprC>
    CTypeConvert<'itm, Vec<S>, SliceMut<C>> for Vec<R>
{
    type RustStore = (Vec<C>, Vec<R::RustStore>);
    type FfiStore = Vec<R::FfiStore>;

    fn into_repr_c(self, store: &'itm mut Self::RustStore) -> SliceMut<C> {
        let vec = self;

        store.1 = core::iter::repeat_with(Default::default)
            .take(vec.len())
            .collect();

        store.0 = vec
            .into_iter()
            .zip(&mut store.1)
            .map(|(item, substore)| item.into_repr_c(substore))
            .collect();

        SliceMut::from_slice(Some(&mut store.0))
    }
    unsafe fn try_from_repr_c(
        source: SliceMut<C>,
        store: &'itm mut Self::FfiStore,
    ) -> Result<Self> {
        let slice = source.into_rust().ok_or(FfiReturn::ArgIsNull)?;

        *store = core::iter::repeat_with(Default::default)
            .take(slice.len())
            .collect();

        let vec: Vec<ManuallyDrop<R>> = slice
            .iter()
            .copied()
            .zip(store)
            .map(|(item, substore)| R::try_from_repr_c(item, substore).map(ManuallyDrop::new))
            .collect::<core::result::Result<_, _>>()?;

        Ok(vec
            .iter()
            .cloned()
            .map(ManuallyDrop::into_inner)
            .collect::<Vec<_>>())
    }
}

impl<R: CWrapperType<S>, S: Cloned> CWrapperType<Vec<S>> for Vec<R> {
    type InputType = Vec<R::InputType>;
    type ReturnType = Vec<R::ReturnType>;
}
impl<R: NonLocal<S>, S: Cloned> COutPtr<Vec<S>> for Vec<R> {
    type OutPtr = OutBoxedSlice<R::ReprC>;
}
impl<'itm, R: NonLocal<S> + CTypeConvert<'itm, S, R::ReprC> + Clone + 'itm, S: Cloned + 'itm>
    COutPtrWrite<Vec<S>> for Vec<R>
{
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        let mut store = <(Vec<R::ReprC>, Vec<R::RustStore>)>::default();
        // NOTE: Bypasses the erroneous lifetime check.
        // Correct as long as `R::into_repr_c` doesn't return a reference to the store (`R: NonLocal`)
        let store_borrow = &mut *addr_of_mut!(store);
        CTypeConvert::<Vec<S>, _>::into_repr_c(self, store_borrow);
        out_ptr.write(OutBoxedSlice::from_vec(Some(store.0)));
    }
}
impl<'itm, R: NonLocal<S> + CTypeConvert<'itm, S, R::ReprC> + Clone + 'itm, S: Cloned + 'itm>
    COutPtrRead<Vec<S>> for Vec<R>
{
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self> {
        let slice = SliceMut::from_raw_parts_mut(out_ptr.as_mut_ptr(), out_ptr.len());

        let mut store = Vec::default();
        // NOTE: Bypasses the erroneous lifetime check.
        // Correct as long as `R::try_from_repr_c` doesn't return a reference to the store (`R: NonLocal`)
        let store_borrow = &mut *addr_of_mut!(store);
        let res = Self::try_from_repr_c(slice, store_borrow);

        if !out_ptr.deallocate() {
            return Err(FfiReturn::TrapRepresentation);
        }

        res
    }
}

impl<R: CType<S>, S: Cloned, const N: usize> CType<[S; N]> for [R; N] {
    type ReprC = [R::ReprC; N];
}
impl<'itm, R: CTypeConvert<'itm, S, C> + Clone, S: Cloned, C: ReprC, const N: usize>
    CTypeConvert<'itm, [S; N], [C; N]> for [R; N]
where
    [R::RustStore; N]: Default,
    [R::FfiStore; N]: Default,
{
    type RustStore = [R::RustStore; N];
    type FfiStore = [R::FfiStore; N];

    fn into_repr_c(self, store: &'itm mut Self::RustStore) -> [C; N] {
        *store = default_init_arr();

        let array = self
            .into_iter()
            .zip(store.iter_mut())
            .map(|(item, substore)| item.into_repr_c(substore))
            .collect::<Vec<_>>()
            .try_into();

        // SAFETY: Vec<T> length is N
        unsafe { array.unwrap_unchecked() }
    }
    unsafe fn try_from_repr_c(source: [C; N], store: &'itm mut Self::FfiStore) -> Result<Self> {
        let array: [ManuallyDrop<R>; N] = source
            .into_iter()
            .zip(store.iter_mut())
            .map(|(item, substore)| R::try_from_repr_c(item, substore).map(ManuallyDrop::new))
            .collect::<core::result::Result<Vec<_>, FfiReturn>>()?
            .try_into()
            .unwrap_unchecked();

        Ok(array
            .iter()
            .cloned()
            .map(ManuallyDrop::into_inner)
            .collect::<Vec<_>>()
            .try_into()
            .unwrap_unchecked())
    }
}
impl<'itm, R: CTypeConvert<'itm, S, C> + Clone, S: Cloned, C: ReprC, const N: usize>
    CTypeConvert<'itm, [S; N], *mut [C; N]> for [R; N]
where
    [R::RustStore; N]: Default,
    [R::FfiStore; N]: Default,
    [C; N]: Default,
{
    type RustStore = ([C; N], [R::RustStore; N]);
    type FfiStore = [R::FfiStore; N];

    fn into_repr_c(self, store: &'itm mut Self::RustStore) -> *mut [C; N] {
        store.0 = self.into_repr_c(&mut store.1);
        &mut store.0
    }
    unsafe fn try_from_repr_c(
        source: *mut [C; N],
        store: &'itm mut Self::FfiStore,
    ) -> Result<Self> {
        if source.is_null() {
            return Err(FfiReturn::ArgIsNull);
        }

        Self::try_from_repr_c(source.read(), store)
    }
}

impl<R: CWrapperType<S>, S: Cloned, const N: usize> CWrapperType<[S; N]> for [R; N] {
    type InputType = [R::InputType; N];
    type ReturnType = [R::ReturnType; N];
}
impl<R: NonLocal<S> + CType<S>, S: Cloned, const N: usize> COutPtr<[S; N]> for [R; N] {
    type OutPtr = Self::ReprC;
}
impl<
        'itm,
        R: NonLocal<S> + CTypeConvert<'itm, S, R::ReprC> + Clone + 'itm,
        S: Cloned + 'itm,
        const N: usize,
    > COutPtrWrite<[S; N]> for [R; N]
where
    [R::RustStore; N]: Default,
    [R::FfiStore; N]: Default,
{
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        let mut store = Default::default();
        // NOTE: Bypasses the erroneous lifetime check.
        // Correct as long as `R::into_repr_c` doesn't return a reference to the store (`R: NonLocal`)
        let store_borrow = &mut *addr_of_mut!(store);
        let item = Self::into_repr_c(self, store_borrow);

        out_ptr.write(item);
    }
}
impl<
        'itm,
        R: NonLocal<S> + CTypeConvert<'itm, S, R::ReprC> + Clone + 'itm,
        S: Cloned + 'itm,
        const N: usize,
    > COutPtrRead<[S; N]> for [R; N]
where
    //[R; N]: CTypeConvert<'itm, [S; N], [R; N]::ReprC>
    [R::RustStore; N]: Default,
    [R::FfiStore; N]: Default,
{
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self> {
        let mut store = Default::default();
        // NOTE: Bypasses the erroneous lifetime check.
        // Correct as long as `R::try_from_repr_c` doesn't return a reference to the store (`R: NonLocal`)
        let store_borrow = &mut *addr_of_mut!(store);
        Self::try_from_repr_c(out_ptr, store_borrow)
    }
}

/* ---------------------------------------Robust-------------------------------------- */

impl<R: ReprC> CType<Robust> for R {
    type ReprC = Self;
}
impl<R: ReprC> CTypeConvert<'_, Robust, R> for R {
    type RustStore = ();
    type FfiStore = ();

    fn into_repr_c(self, _: &mut ()) -> R {
        self
    }

    unsafe fn try_from_repr_c(source: R, _: &mut ()) -> Result<Self> {
        Ok(source)
    }
}
impl<R: ReprC, const N: usize> CTypeConvert<'_, Robust, *mut [R; N]> for [R; N] {
    type RustStore = Option<Self>;
    type FfiStore = ();

    fn into_repr_c(self, store: &mut Self::RustStore) -> *mut [R; N] {
        store.insert(self)
    }

    unsafe fn try_from_repr_c(source: *mut [R; N], _: &mut ()) -> Result<Self> {
        if source.is_null() {
            return Err(FfiReturn::ArgIsNull);
        }

        Ok(source.read())
    }
}

impl<R: ReprC> CWrapperType<Robust> for R {
    type InputType = Self;
    type ReturnType = Self;
}
impl<R: ReprC> COutPtr<Robust> for R {
    type OutPtr = Self::ReprC;
}
impl<R: ReprC> COutPtrWrite<Robust> for R {
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        write_non_local::<_, Robust>(self, out_ptr)
    }
}
impl<R: ReprC> COutPtrRead<Robust> for R {
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self> {
        read_non_local::<_, Robust>(out_ptr)
    }
}

impl<R: ReprC> CType<Box<Robust>> for Box<R> {
    type ReprC = *mut R;
}
impl<R: ReprC> CTypeConvert<'_, Box<Robust>, *mut R> for Box<R> {
    type RustStore = Option<Self>;
    type FfiStore = ();

    fn into_repr_c(self, store: &mut Self::RustStore) -> *mut R {
        &mut **store.insert(self)
    }

    unsafe fn try_from_repr_c(source: *mut R, _: &mut ()) -> Result<Self> {
        if source.is_null() {
            return Err(FfiReturn::ArgIsNull);
        }

        Ok(Box::new(source.read()))
    }
}

impl<R: ReprC> CWrapperType<Box<Robust>> for Box<R> {
    type InputType = Self;
    type ReturnType = Self;
}
impl<R: ReprC> COutPtr<Box<Robust>> for Box<R> {
    type OutPtr = R;
}
impl<R: ReprC> COutPtrWrite<Box<Robust>> for Box<R> {
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        out_ptr.write(*self);
    }
}
impl<R: ReprC> COutPtrRead<Box<Robust>> for Box<R> {
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self> {
        CTypeConvert::<Robust, _>::try_from_repr_c(out_ptr, &mut ()).map(Box::new)
    }
}

impl<R: ReprC> CType<&[Robust]> for &[R] {
    type ReprC = SliceRef<R>;
}
impl<R: ReprC> CTypeConvert<'_, &[Robust], SliceRef<R>> for &[R] {
    type RustStore = ();
    type FfiStore = ();

    fn into_repr_c(self, _: &mut ()) -> SliceRef<R> {
        SliceRef::from_slice(Some(self))
    }

    unsafe fn try_from_repr_c(source: SliceRef<R>, _: &mut ()) -> Result<Self> {
        source.into_rust().ok_or(FfiReturn::ArgIsNull)
    }
}

impl<R: ReprC> CWrapperType<&[Robust]> for &[R] {
    type InputType = Self;
    type ReturnType = Self;
}
impl<R: ReprC> COutPtr<&[Robust]> for &[R] {
    type OutPtr = Self::ReprC;
}
impl<R: ReprC> COutPtrWrite<&[Robust]> for &[R] {
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        write_non_local::<_, &[Robust]>(self, out_ptr)
    }
}
impl<R: ReprC> COutPtrRead<&[Robust]> for &[R] {
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self> {
        read_non_local::<_, &[Robust]>(out_ptr)
    }
}

impl<R: ReprC> CWrapperType<&mut [Robust]> for &mut [R] {
    type InputType = Self;
    type ReturnType = Self;
}
impl<R: ReprC> CType<&mut [Robust]> for &mut [R] {
    type ReprC = SliceMut<R>;
}
impl<R: ReprC> CTypeConvert<'_, &mut [Robust], SliceMut<R>> for &mut [R] {
    type RustStore = ();
    type FfiStore = ();

    fn into_repr_c(self, _: &mut ()) -> SliceMut<R> {
        SliceMut::from_slice(Some(self))
    }

    unsafe fn try_from_repr_c(source: SliceMut<R>, _: &mut ()) -> Result<Self> {
        source.into_rust().ok_or(FfiReturn::ArgIsNull)
    }
}

impl<R: ReprC> COutPtr<&mut [Robust]> for &mut [R] {
    type OutPtr = Self::ReprC;
}
impl<R: ReprC> COutPtrWrite<&mut [Robust]> for &mut [R] {
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        write_non_local::<_, &mut [Robust]>(self, out_ptr)
    }
}
impl<R: ReprC> COutPtrRead<&mut [Robust]> for &mut [R] {
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self> {
        read_non_local::<_, &mut [Robust]>(out_ptr)
    }
}

impl<R: ReprC> CType<Vec<Robust>> for Vec<R> {
    type ReprC = SliceMut<R>;
}
impl<R: ReprC> CTypeConvert<'_, Vec<Robust>, SliceMut<R>> for Vec<R> {
    type RustStore = Self;
    type FfiStore = ();

    fn into_repr_c(self, store: &mut Self::RustStore) -> SliceMut<R> {
        *store = self;
        SliceMut::from_slice(Some(store))
    }

    unsafe fn try_from_repr_c(source: SliceMut<R>, _: &mut ()) -> Result<Self> {
        source
            .into_rust()
            .ok_or(FfiReturn::ArgIsNull)
            .map(|slice| slice.to_vec())
    }
}

impl<R: ReprC> CWrapperType<Vec<Robust>> for Vec<R> {
    type InputType = Self;
    type ReturnType = Self;
}
impl<R: ReprC> COutPtr<Vec<Robust>> for Vec<R> {
    type OutPtr = OutBoxedSlice<R>;
}
impl<R: ReprC> COutPtrWrite<Vec<Robust>> for Vec<R> {
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        let mut store = Vec::default();
        CTypeConvert::<Vec<Robust>, _>::into_repr_c(self, &mut store);
        out_ptr.write(OutBoxedSlice::from_vec(Some(store)));
    }
}
impl<R: ReprC> COutPtrRead<Vec<Robust>> for Vec<R> {
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self> {
        let slice = SliceMut::from_raw_parts_mut(out_ptr.as_mut_ptr(), out_ptr.len());
        let res = CTypeConvert::<Vec<Robust>, _>::try_from_repr_c(slice, &mut ());

        if !out_ptr.deallocate() {
            return Err(FfiReturn::TrapRepresentation);
        }

        res
    }
}

// SAFETY: Type doesn't use store during conversion
unsafe impl<R: ReprC> NonLocal<Robust> for R {}
// SAFETY: Type doesn't use store during conversion
unsafe impl<R: ReprC> NonLocal<&[Robust]> for &[R] {}
// SAFETY: Type doesn't use store during conversion
unsafe impl<R: ReprC> NonLocal<&mut [Robust]> for &mut [R] {}

/* ---------------------------------------Opaque-------------------------------------- */

impl<R> CType<Opaque> for R {
    type ReprC = *mut R;
}
impl<R> CTypeConvert<'_, Opaque, *mut R> for R {
    type RustStore = ();
    type FfiStore = ();

    fn into_repr_c(self, _: &mut ()) -> *mut R {
        Box::into_raw(Box::new(self))
    }
    unsafe fn try_from_repr_c(source: *mut R, _: &mut ()) -> Result<Self> {
        if source.is_null() {
            return Err(FfiReturn::ArgIsNull);
        }

        Ok(*Box::from_raw(source))
    }
}

impl<R> COutPtr<Opaque> for R {
    type OutPtr = Self::ReprC;
}
impl<R> COutPtrWrite<Opaque> for R {
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        write_non_local::<_, Opaque>(self, out_ptr)
    }
}

impl<R> CType<Box<Opaque>> for Box<R> {
    type ReprC = *mut R;
}
impl<R> CTypeConvert<'_, Box<Opaque>, *mut R> for Box<R> {
    type RustStore = ();
    type FfiStore = ();

    fn into_repr_c(self, _: &mut ()) -> *mut R {
        Box::into_raw(self)
    }

    unsafe fn try_from_repr_c(source: *mut R, _: &mut ()) -> Result<Self> {
        if source.is_null() {
            return Err(FfiReturn::ArgIsNull);
        }

        Ok(Box::from_raw(source))
    }
}

impl<R> COutPtr<Box<Opaque>> for Box<R> {
    type OutPtr = Self::ReprC;
}
impl<R> COutPtrWrite<Box<Opaque>> for Box<R> {
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        write_non_local::<_, Box<Opaque>>(self, out_ptr)
    }
}

impl<R> CType<&[Opaque]> for &[R] {
    type ReprC = SliceRef<*const R>;
}
impl<'slice, R: Clone> CTypeConvert<'slice, &'slice [Opaque], SliceRef<*const R>>
    for &'slice [R]
{
    type RustStore = Vec<*const R>;
    type FfiStore = Vec<R>;

    fn into_repr_c(self, store: &mut Self::RustStore) -> SliceRef<*const R> {
        *store = self.iter().map(|item| item as *const R).collect();
        SliceRef::from_slice(Some(store))
    }

    unsafe fn try_from_repr_c(
        source: SliceRef<*const R>,
        store: &'slice mut Self::FfiStore,
    ) -> Result<Self> {
        let source = source.into_rust().ok_or(FfiReturn::ArgIsNull)?;

        *store = source
            .iter()
            .map(|item| {
                item
                        .as_ref()
                        // NOTE: This function clones every opaque pointer in the slice. This could
                        // be avoided with the entire slice being opaque, if that even makes sense.
                        .cloned()
                        .ok_or(FfiReturn::ArgIsNull)
            })
            .collect::<core::result::Result<_, _>>()?;

        Ok(store)
    }
}

impl<R> COutPtr<&[Opaque]> for &[R] {
    type OutPtr = OutBoxedSlice<*const R>;
}
impl<R: Clone> COutPtrWrite<&[Opaque]> for &[R] {
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        let mut store = Vec::default();
        CTypeConvert::<&[Opaque], _>::into_repr_c(self, &mut store);
        out_ptr.write(OutBoxedSlice::from_vec(Some(store)));
    }
}

impl<R> CType<&mut [Opaque]> for &mut [R] {
    type ReprC = SliceMut<*mut R>;
}
impl<'slice, R: Clone> CTypeConvert<'slice, &mut [Opaque], SliceMut<*mut R>> for &'slice mut [R] {
    type RustStore = Vec<*mut R>;
    type FfiStore = Vec<R>;

    fn into_repr_c(self, store: &mut Self::RustStore) -> SliceMut<*mut R> {
        *store = self.iter_mut().map(|item| item as *mut R).collect();

        SliceMut::from_slice(Some(store))
    }

    unsafe fn try_from_repr_c(
        source: SliceMut<*mut R>,
        store: &'slice mut Self::FfiStore,
    ) -> Result<Self> {
        let source = source.into_rust().ok_or(FfiReturn::ArgIsNull)?;

        *store = source
            .iter()
            .map(|item| {
                item
                        .as_mut()
                        // NOTE: This function clones every opaque pointer in the slice. This could
                        // be avoided with the entire slice being opaque, if that even makes sense.
                        .cloned()
                        .ok_or(FfiReturn::ArgIsNull)
            })
            .collect::<core::result::Result<_, _>>()?;

        Ok(store)
    }
}

impl<R> COutPtr<&mut [Opaque]> for &mut [R] {
    type OutPtr = OutBoxedSlice<*mut R>;
}
impl<R: Clone> COutPtrWrite<&mut [Opaque]> for &mut [R] {
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        let mut store = Vec::default();
        CTypeConvert::<&mut [Opaque], _>::into_repr_c(self, &mut store);
        out_ptr.write(OutBoxedSlice::from_vec(Some(store)));
    }
}

impl<R> CType<Vec<Opaque>> for Vec<R> {
    type ReprC = SliceMut<*mut R>;
}
impl<R> CTypeConvert<'_, Vec<Opaque>, SliceMut<*mut R>> for Vec<R> {
    type RustStore = Vec<*mut R>;
    type FfiStore = ();

    fn into_repr_c(self, store: &mut Self::RustStore) -> SliceMut<*mut R> {
        *store = self.into_iter().map(Box::new).map(Box::into_raw).collect();
        SliceMut::from_slice(Some(store))
    }

    unsafe fn try_from_repr_c(source: SliceMut<*mut R>, _: &mut ()) -> Result<Self> {
        source
            .into_rust()
            .ok_or(FfiReturn::ArgIsNull)?
            .iter()
            .map(|&item| {
                if let Some(item) = item.as_mut() {
                    return Ok(*Box::from_raw(item));
                }

                Err(FfiReturn::ArgIsNull)
            })
            .collect::<core::result::Result<_, _>>()
    }
}

impl<R> COutPtr<Vec<Opaque>> for Vec<R> {
    type OutPtr = OutBoxedSlice<*mut R>;
}
impl<R> COutPtrWrite<Vec<Opaque>> for Vec<R> {
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        let mut store = Vec::default();
        CTypeConvert::<Vec<Opaque>, _>::into_repr_c(self, &mut store);
        out_ptr.write(OutBoxedSlice::from_vec(Some(store)));
    }
}

impl<R, const N: usize> CType<[Opaque; N]> for [R; N] {
    type ReprC = [*mut R; N];
}
impl<R, const N: usize> CTypeConvert<'_, [Opaque; N], [*mut R; N]> for [R; N] {
    type RustStore = ();
    type FfiStore = ();

    fn into_repr_c(self, _: &mut Self::RustStore) -> [*mut R; N] {
        let array = self
            .into_iter()
            .map(Box::new)
            .map(Box::into_raw)
            .collect::<Vec<_>>()
            .try_into();

        // SAFETY: Vec<T> length is N
        unsafe { array.unwrap_unchecked() }
    }

    unsafe fn try_from_repr_c(source: [*mut R; N], _: &mut ()) -> Result<Self> {
        Ok(source
            .into_iter()
            .map(|item| {
                if let Some(item) = item.as_mut() {
                    return Ok(*Box::from_raw(item));
                }

                Err(FfiReturn::ArgIsNull)
            })
            .collect::<core::result::Result<Vec<R>, _>>()?
            .try_into()
            .unwrap_unchecked())
    }
}
impl<R, const N: usize> CTypeConvert<'_, [Opaque; N], *mut [*mut R; N]> for [R; N] {
    type RustStore = Option<[*mut R; N]>;
    type FfiStore = ();

    fn into_repr_c(self, store: &mut Self::RustStore) -> *mut [*mut R; N] {
        store.insert(self.into_repr_c(&mut ()))
    }

    unsafe fn try_from_repr_c(source: *mut [*mut R; N], _: &mut ()) -> Result<Self> {
        if source.is_null() {
            return Err(FfiReturn::ArgIsNull);
        }

        CTypeConvert::try_from_repr_c(source.read(), &mut ())
    }
}

impl<R, const N: usize> COutPtr<[Opaque; N]> for [R; N] {
    type OutPtr = Self::ReprC;
}
impl<R, const N: usize> COutPtrWrite<[Opaque; N]> for [R; N] {
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        write_non_local::<_, [Opaque; N]>(self, out_ptr)
    }
}

// SAFETY: Type doesn't use store during conversion
unsafe impl<R> NonLocal<Opaque> for R {}
// SAFETY: Type doesn't use store during conversion
unsafe impl<R> NonLocal<Box<Opaque>> for Box<R> {}
// SAFETY: Type doesn't use store during conversion
unsafe impl<R, const N: usize> NonLocal<[Opaque; N]> for [R; N] {}

/* ---------------------------------------Extern-------------------------------------- */

impl<'itm, R: External> CType<&'itm Extern> for &'itm R {
    type ReprC = *const Extern;
}
impl<'itm, R: External> CWrapperType<&'itm Extern> for &'itm R {
    type InputType = R::RefType<'itm>;
    type ReturnType = R::RefType<'itm>;
}

impl<'itm, R: External> CWrapperType<Box<&'itm Extern>> for Box<&'itm R> {
    type InputType = Box<R::RefType<'itm>>;
    type ReturnType = Box<R::RefType<'itm>>;
}
impl<'itm, R: External> CWrapperType<&'itm [&'itm Extern]> for &'itm [&'itm R] {
    type InputType = &'itm [R::RefType<'itm>];
    type ReturnType = &'itm [R::RefType<'itm>];
}
impl<'itm, R: External> CWrapperType<&'itm mut [&'itm Extern]> for &'itm mut [&'itm R] {
    type InputType = &'itm mut [R::RefType<'itm>];
    type ReturnType = &'itm mut [R::RefType<'itm>];
}
impl<'itm, R: External> CWrapperType<Vec<&'itm Extern>> for Vec<&'itm R> {
    type InputType = Vec<R::RefType<'itm>>;
    type ReturnType = Vec<R::RefType<'itm>>;
}
impl<'itm, R: External, const N: usize> CWrapperType<[&'itm Extern; N]> for [&'itm R; N] {
    type InputType = [R::RefType<'itm>; N];
    type ReturnType = [R::RefType<'itm>; N];
}

impl<'itm, R: External> CWrapperType<&'itm mut Extern> for &'itm mut R {
    type InputType = R::RefMutType<'itm>;
    type ReturnType = R::RefMutType<'itm>;
}
impl<'itm, R: External> CWrapperType<Box<&'itm mut Extern>> for Box<&'itm mut R> {
    type InputType = Box<R::RefMutType<'itm>>;
    type ReturnType = Box<R::RefMutType<'itm>>;
}
impl<'itm, R: External> CWrapperType<&'itm [&'itm mut Extern]> for &'itm [&'itm mut R] {
    type InputType = &'itm [R::RefMutType<'itm>];
    type ReturnType = &'itm [R::RefMutType<'itm>];
}
impl<'itm, R: External> CWrapperType<&'itm mut [&'itm mut Extern]> for &'itm mut [&'itm mut R] {
    type InputType = &'itm mut [R::RefMutType<'itm>];
    type ReturnType = &'itm mut [R::RefMutType<'itm>];
}
impl<'itm, R: External> CWrapperType<Vec<&'itm mut Extern>> for Vec<&'itm mut R> {
    type InputType = Vec<R::RefMutType<'itm>>;
    type ReturnType = Vec<R::RefMutType<'itm>>;
}
impl<'itm, R: External, const N: usize> CWrapperType<[&'itm mut Extern; N]> for [&'itm mut R; N] {
    type InputType = [R::RefMutType<'itm>; N];
    type ReturnType = [R::RefMutType<'itm>; N];
}

impl<R: External> CType<Box<Extern>> for Box<R> {
    type ReprC = *mut Extern;
}
impl<R: External> CTypeConvert<'_, Box<Extern>, *mut Extern> for Box<R> {
    type RustStore = ();
    type FfiStore = ();

    fn into_repr_c(self, _: &mut ()) -> *mut Extern {
        ManuallyDrop::new(*self).as_extern_ptr_mut()
    }

    unsafe fn try_from_repr_c(source: *mut Extern, _: &mut ()) -> Result<Self> {
        if source.is_null() {
            return Err(FfiReturn::ArgIsNull);
        }

        Ok(Box::new(External::from_extern_ptr(source)))
    }
}

impl<R: External> CWrapperType<Box<Extern>> for Box<R> {
    type InputType = R;
    type ReturnType = R;
}
impl<R: External> COutPtr<Box<Extern>> for Box<R> {
    type OutPtr = Self::ReprC;
}
impl<R: External> COutPtrRead<Box<Extern>> for Box<R> {
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self> {
        read_non_local::<_, Box<Extern>>(out_ptr)
    }
}

unsafe impl<R: External> NonLocal<Box<Extern>> for Box<R> {}

/* ------------------------------------Transparent------------------------------------ */

impl<R: Transmute> CType<Transparent> for R
where
    R::Target: FfiType,
{
    type ReprC = <R::Target as FfiType>::ReprC;
}
impl<'itm, R: Transmute, C: ReprC> CTypeConvert<'itm, Transparent, C> for R
where
    R::Target: FfiConvert<'itm, C>,
{
    type RustStore = <R::Target as FfiConvert<'itm, C>>::RustStore;
    type FfiStore = <R::Target as FfiConvert<'itm, C>>::FfiStore;

    fn into_repr_c(self, store: &'itm mut Self::RustStore) -> C {
        transmute_into_target(self).into_ffi(store)
    }

    unsafe fn try_from_repr_c(source: C, store: &'itm mut Self::FfiStore) -> Result<Self> {
        FfiConvert::try_from_ffi(source, store).and_then(|inner| transmute_from_target(inner))
    }
}

impl<R: Transmute> CWrapperType<Transparent> for R
where
    R::Target: FfiWrapperType,
    <R::Target as FfiWrapperType>::InputType: WrapperTypeOf<Self>,
    <R::Target as FfiWrapperType>::ReturnType: WrapperTypeOf<Self>,
{
    type InputType = <<R::Target as FfiWrapperType>::InputType as WrapperTypeOf<Self>>::Type;
    type ReturnType = <<R::Target as FfiWrapperType>::ReturnType as WrapperTypeOf<Self>>::Type;
}
impl<R: Transmute> COutPtr<Transparent> for R
where
    R::Target: FfiOutPtr,
{
    type OutPtr = <R::Target as FfiOutPtr>::OutPtr;
}
impl<R: Transmute> COutPtrWrite<Transparent> for R
where
    R::Target: FfiOutPtrWrite,
{
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        FfiOutPtrWrite::write_out(transmute_into_target(self), out_ptr);
    }
}
impl<R: Transmute> COutPtrRead<Transparent> for R
where
    R::Target: FfiOutPtrRead,
{
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self> {
        FfiOutPtrRead::try_read_out(out_ptr).and_then(|output| transmute_from_target(output))
    }
}

impl<R: Transmute> CType<Box<Transparent>> for Box<R>
where
    Box<R::Target>: FfiType,
{
    type ReprC = <Box<R::Target> as FfiType>::ReprC;
}
impl<'itm, R: Transmute, C: ReprC> CTypeConvert<'itm, Box<Transparent>, C> for Box<R>
where
    Box<R::Target>: FfiConvert<'itm, C>,
{
    type RustStore = <Box<R::Target> as FfiConvert<'itm, C>>::RustStore;
    type FfiStore = <Box<R::Target> as FfiConvert<'itm, C>>::FfiStore;

    fn into_repr_c(self, store: &'itm mut Self::RustStore) -> C {
        transmute_into_target_box(self).into_ffi(store)
    }

    unsafe fn try_from_repr_c(source: C, store: &'itm mut Self::FfiStore) -> Result<Self> {
        Box::<R::Target>::try_from_ffi(source, store)
            .and_then(|output| transmute_from_target_box(output))
    }
}

impl<R: Transmute> CWrapperType<Box<Transparent>> for Box<R>
where
    Box<R::Target>: FfiWrapperType,
    <Box<R::Target> as FfiWrapperType>::InputType: WrapperTypeOf<Self>,
    <Box<R::Target> as FfiWrapperType>::ReturnType: WrapperTypeOf<Self>,
{
    type InputType = <<Box<R::Target> as FfiWrapperType>::InputType as WrapperTypeOf<Self>>::Type;
    type ReturnType = <<Box<R::Target> as FfiWrapperType>::ReturnType as WrapperTypeOf<Self>>::Type;
}
impl<R: Transmute> COutPtr<Box<Transparent>> for Box<R>
where
    Box<R::Target>: FfiOutPtr,
{
    type OutPtr = <Box<R::Target> as FfiOutPtr>::OutPtr;
}
impl<R: Transmute> COutPtrWrite<Box<Transparent>> for Box<R>
where
    Box<R::Target>: FfiOutPtrWrite,
{
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        FfiOutPtrWrite::write_out(transmute_into_target_box(self), out_ptr);
    }
}
impl<R: Transmute> COutPtrRead<Box<Transparent>> for Box<R>
where
    Box<R::Target>: FfiOutPtrRead,
{
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self> {
        Box::<R::Target>::try_read_out(out_ptr).and_then(|output| transmute_from_target_box(output))
    }
}

impl<'slice, R: Transmute> CType<&'slice [Transparent]> for &'slice [R]
where
    &'slice [R::Target]: FfiType,
{
    type ReprC = <&'slice [R::Target] as FfiType>::ReprC;
}
impl<'slice, R: Transmute, C: ReprC> CTypeConvert<'slice, &'slice [Transparent], C>
    for &'slice [R]
where
    &'slice [R::Target]: FfiConvert<'slice, C>,
{
    type RustStore = <&'slice [R::Target] as FfiConvert<'slice, C>>::RustStore;
    type FfiStore = <&'slice [R::Target] as FfiConvert<'slice, C>>::FfiStore;

    fn into_repr_c(self, store: &'slice mut Self::RustStore) -> C {
        transmute_into_target_slice_ref(self).into_ffi(store)
    }

    unsafe fn try_from_repr_c(source: C, store: &'slice mut Self::FfiStore) -> Result<Self> {
        let slice = <&[R::Target]>::try_from_ffi(source, store)?;
        transmute_from_target_slice_ref(slice)
    }
}

impl<'slice, R: Transmute> CWrapperType<&'slice [Transparent]> for &'slice [R]
where
    &'slice [R::Target]: FfiWrapperType,
    <&'slice [R::Target] as FfiWrapperType>::InputType: WrapperTypeOf<Self>,
    <&'slice [R::Target] as FfiWrapperType>::ReturnType: WrapperTypeOf<Self>,
{
    type InputType =
        <<&'slice [R::Target] as FfiWrapperType>::InputType as WrapperTypeOf<Self>>::Type;
    type ReturnType =
        <<&'slice [R::Target] as FfiWrapperType>::ReturnType as WrapperTypeOf<Self>>::Type;
}
impl<'slice, R: Transmute> COutPtr<&'slice [Transparent]> for &'slice [R]
where
    &'slice [R::Target]: FfiOutPtr,
{
    type OutPtr = <&'slice [R::Target] as FfiOutPtr>::OutPtr;
}
impl<'slice, R: Transmute> COutPtrWrite<&'slice [Transparent]> for &'slice [R]
where
    &'slice [R::Target]: FfiOutPtrWrite,
{
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        FfiOutPtrWrite::write_out(transmute_into_target_slice_ref(self), out_ptr);
    }
}
impl<'itm, R: Transmute> COutPtrRead<&'itm [Transparent]> for &'itm [R]
where
    &'itm [R::Target]: FfiOutPtrRead,
{
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self> {
        <&[R::Target]>::try_read_out(out_ptr)
            .and_then(|output| transmute_from_target_slice_ref(output))
    }
}

impl<'slice, R: Transmute> CType<&'slice mut [Transparent]> for &'slice mut [R]
where
    &'slice mut [R::Target]: FfiType,
{
    type ReprC = <&'slice mut [R::Target] as FfiType>::ReprC;
}
impl<'slice, R: Transmute, C: ReprC> CTypeConvert<'slice, &'slice mut [Transparent], C>
    for &'slice mut [R]
where
    &'slice mut [R::Target]: FfiConvert<'slice, C>,
{
    type RustStore = <&'slice mut [R::Target] as FfiConvert<'slice, C>>::RustStore;
    type FfiStore = <&'slice mut [R::Target] as FfiConvert<'slice, C>>::FfiStore;

    fn into_repr_c(self, store: &'slice mut Self::RustStore) -> C {
        transmute_into_target_slice_mut(self).into_ffi(store)
    }

    unsafe fn try_from_repr_c(source: C, store: &'slice mut Self::FfiStore) -> Result<Self> {
        <&mut [R::Target]>::try_from_ffi(source, store)
            .and_then(|output| transmute_from_target_slice_mut(output))
    }
}

impl<'slice, R: Transmute> CWrapperType<&'slice mut [Transparent]> for &'slice mut [R]
where
    &'slice mut [R::Target]: FfiWrapperType,
    <&'slice mut [R::Target] as FfiWrapperType>::InputType: WrapperTypeOf<Self>,
    <&'slice mut [R::Target] as FfiWrapperType>::ReturnType: WrapperTypeOf<Self>,
{
    type InputType =
        <<&'slice mut [R::Target] as FfiWrapperType>::InputType as WrapperTypeOf<Self>>::Type;
    type ReturnType =
        <<&'slice mut [R::Target] as FfiWrapperType>::ReturnType as WrapperTypeOf<Self>>::Type;
}
impl<'slice, R: Transmute> COutPtr<&'slice mut [Transparent]> for &'slice mut [R]
where
    &'slice mut [R::Target]: FfiOutPtr,
{
    type OutPtr = <&'slice mut [R::Target] as FfiOutPtr>::OutPtr;
}
impl<'slice, R: Transmute> COutPtrWrite<&'slice mut [Transparent]> for &'slice mut [R]
where
    &'slice mut [R::Target]: FfiOutPtrWrite,
{
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        FfiOutPtrWrite::write_out(transmute_into_target_slice_mut(self), out_ptr);
    }
}
impl<'itm, R: Transmute> COutPtrRead<&'itm mut [Transparent]> for &'itm mut [R]
where
    &'itm mut [R::Target]: FfiOutPtrRead,
{
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self> {
        <&mut [R::Target]>::try_read_out(out_ptr)
            .and_then(|output| transmute_from_target_slice_mut(output))
    }
}

impl<R: Transmute> CType<Vec<Transparent>> for Vec<R>
where
    Vec<R::Target>: FfiType,
{
    type ReprC = <Vec<R::Target> as FfiType>::ReprC;
}
impl<'itm, R: Transmute, C: ReprC> CTypeConvert<'itm, Vec<Transparent>, C> for Vec<R>
where
    Vec<R::Target>: FfiConvert<'itm, C>,
{
    type RustStore = <Vec<R::Target> as FfiConvert<'itm, C>>::RustStore;
    type FfiStore = <Vec<R::Target> as FfiConvert<'itm, C>>::FfiStore;

    fn into_repr_c(self, store: &'itm mut Self::RustStore) -> C {
        transmute_into_target_vec(self).into_ffi(store)
    }

    unsafe fn try_from_repr_c(source: C, store: &'itm mut Self::FfiStore) -> Result<Self> {
        <Vec<R::Target>>::try_from_ffi(source, store)
            .and_then(|output| transmute_from_target_vec(output))
    }
}

impl<R: Transmute> CWrapperType<Vec<Transparent>> for Vec<R>
where
    Vec<R::Target>: FfiWrapperType,
    <Vec<R::Target> as FfiWrapperType>::InputType: WrapperTypeOf<Self>,
    <Vec<R::Target> as FfiWrapperType>::ReturnType: WrapperTypeOf<Self>,
{
    type InputType = <<Vec<R::Target> as FfiWrapperType>::InputType as WrapperTypeOf<Self>>::Type;
    type ReturnType = <<Vec<R::Target> as FfiWrapperType>::ReturnType as WrapperTypeOf<Self>>::Type;
}
impl<R: Transmute> COutPtr<Vec<Transparent>> for Vec<R>
where
    Vec<R::Target>: FfiOutPtr,
{
    type OutPtr = <Vec<R::Target> as FfiOutPtr>::OutPtr;
}
impl<R: Transmute> COutPtrWrite<Vec<Transparent>> for Vec<R>
where
    Vec<R::Target>: FfiOutPtrWrite,
{
    unsafe fn write_out(self, out_ptr: *mut Self::OutPtr) {
        FfiOutPtrWrite::write_out(transmute_into_target_vec(self), out_ptr);
    }
}
impl<R: Transmute> COutPtrRead<Vec<Transparent>> for Vec<R>
where
    Vec<R::Target>: FfiOutPtrRead,
{
    unsafe fn try_read_out(out_ptr: Self::OutPtr) -> Result<Self> {
        <Vec<R::Target>>::try_read_out(out_ptr).and_then(|output| transmute_from_target_vec(output))
    }
}

// SAFETY: Type doesn't return a reference to the store if the inner type doesn't
unsafe impl<R: Transmute + COutPtr<Transparent>> NonLocal<Transparent> for R where
    R::Target: Ir + NonLocal<<R::Target as Ir>::Type>
{
}
// SAFETY: Type doesn't return a reference to the store if the inner type doesn't
unsafe impl<R: Transmute> NonLocal<Box<Transparent>> for Box<R> where
    Box<R::Target>: Ir + NonLocal<<Box<R::Target> as Ir>::Type>
{
}
// SAFETY: Type doesn't return a reference to the store if the inner type doesn't
unsafe impl<'slice, R: Transmute> NonLocal<&'slice [Transparent]> for &'slice [R] where
    &'slice [R::Target]: Ir + NonLocal<<&'slice [R::Target] as Ir>::Type>
{
}
// SAFETY: Type doesn't return a reference to the store if the inner type doesn't
unsafe impl<'slice, R: Transmute> NonLocal<&'slice mut [Transparent]> for &'slice mut [R] where
    &'slice mut [R::Target]: Ir + NonLocal<<&'slice mut [R::Target] as Ir>::Type>
{
}
// SAFETY: Type doesn't return a reference to the store if the inner type doesn't
unsafe impl<R: Transmute> NonLocal<Vec<Transparent>> for Vec<R> where
    Vec<R::Target>: Ir + NonLocal<<Vec<R::Target> as Ir>::Type>
{
}

#[repr(C)]
union TransmuteHelper<R: Transmute> {
    source: ManuallyDrop<R>,
    target: ManuallyDrop<R::Target>,
}

fn transmute_into_target<R: Transmute>(source: R) -> R::Target {
    let transmute_helper = TransmuteHelper {
        source: ManuallyDrop::new(source),
    };

    // SAFETY: Transmute is always valid because R::Target is a superset of R
    ManuallyDrop::into_inner(unsafe { transmute_helper.target })
}
unsafe fn transmute_from_target<R: Transmute>(source: R::Target) -> Result<R> {
    if !R::is_valid(&source) {
        return Err(FfiReturn::TrapRepresentation);
    }

    let transmute_helper = TransmuteHelper {
        target: ManuallyDrop::new(source),
    };

    Ok(ManuallyDrop::into_inner(transmute_helper.source))
}

fn transmute_into_target_box<R: Transmute>(source: Box<R>) -> Box<R::Target> {
    // SAFETY: `R` is guaranteed to be transmutable into `R::Target`
    unsafe { Box::from_raw(Box::into_raw(source).cast::<R::Target>()) }
}
unsafe fn transmute_from_target_box<R: Transmute>(source: Box<R::Target>) -> Result<Box<R>> {
    if !R::is_valid(&source) {
        return Err(FfiReturn::TrapRepresentation);
    }

    Ok(Box::from_raw(Box::into_raw(source).cast::<R>()))
}

fn transmute_into_target_slice_ref<R: Transmute>(source: &[R]) -> &[R::Target] {
    let (ptr, len) = (source.as_ptr().cast::<R::Target>(), source.len());
    // SAFETY: `R` is guaranteed to be transmutable into `R::Target`
    unsafe { core::slice::from_raw_parts(ptr, len) }
}
unsafe fn transmute_from_target_slice_ref<R: Transmute>(source: &[R::Target]) -> Result<&[R]> {
    if !source.iter().all(|item| R::is_valid(item)) {
        return Err(FfiReturn::TrapRepresentation);
    }

    Ok(core::slice::from_raw_parts(
        source.as_ptr().cast(),
        source.len(),
    ))
}

fn transmute_into_target_slice_mut<R: Transmute>(source: &mut [R]) -> &mut [R::Target] {
    let (ptr, len) = (source.as_mut_ptr().cast::<R::Target>(), source.len());
    // SAFETY: `R` is guaranteed to be transmutable into `R::Target`
    unsafe { core::slice::from_raw_parts_mut(ptr, len) }
}
unsafe fn transmute_from_target_slice_mut<R: Transmute>(
    source: &mut [R::Target],
) -> Result<&mut [R]> {
    if !source.iter_mut().all(|item| R::is_valid(item)) {
        return Err(FfiReturn::TrapRepresentation);
    }

    Ok(core::slice::from_raw_parts_mut(
        source.as_mut_ptr().cast(),
        source.len(),
    ))
}

fn transmute_into_target_vec<R: Transmute>(source: Vec<R>) -> Vec<R::Target> {
    let mut vec = ManuallyDrop::new(source);

    // SAFETY: `Transparency` guarantees `T` can be transmuted into `C`
    unsafe { Vec::from_raw_parts(vec.as_mut_ptr().cast(), vec.len(), vec.capacity()) }
}
unsafe fn transmute_from_target_vec<R: Transmute>(source: Vec<R::Target>) -> Result<Vec<R>> {
    if !source.iter().all(|item| R::is_valid(item)) {
        return Err(FfiReturn::TrapRepresentation);
    }

    let mut vec = ManuallyDrop::new(source);
    Ok(Vec::from_raw_parts(
        vec.as_mut_ptr().cast(),
        vec.len(),
        vec.capacity(),
    ))
}

/* ----------------------------------------------------------------------------------- */

fn default_init_arr<R: Default, const N: usize>() -> [R; N] {
    // SAFETY: Vec<T> length is N
    unsafe {
        TryFrom::try_from(
            core::iter::repeat_with(Default::default)
                .take(N)
                .collect::<Vec<_>>(),
        )
        .unwrap_unchecked()
    }
}

/// Write a rust value into an out-pointer of any type that doesn't return a
/// reference to the store during serialization into an FFI-compatible type
///
/// # Safety
///
/// out-pointer must be valid for writes
pub unsafe fn write_non_local<
    'itm,
    R: NonLocal<S> + CTypeConvert<'itm, S, R::ReprC> + 'itm,
    S: 'itm,
>(
    source: R,
    out_ptr: *mut R::ReprC,
) {
    let mut store = Default::default();
    // NOTE: Bypasses the erroneous lifetime check.
    // Correct as long as `R::into_repr_c` doesn't return a reference to the store (`R: NonLocal`)
    let store_borrow = &mut *addr_of_mut!(store);
    out_ptr.write(CTypeConvert::into_repr_c(source, store_borrow));
}

/// Read a rust value from an out-pointer of any type that doesn't return a reference
/// reference to the store during serialization from an FFI-compatible type
///
/// # Errors
///
/// Check [`CTypeConvert::try_from_repr_c`]
///
/// # Safety
///
/// Check [`CTypeConvert::try_from_repr_c`]
pub unsafe fn read_non_local<
    'itm,
    R: NonLocal<S> + CTypeConvert<'itm, S, R::ReprC> + 'itm,
    S: 'itm,
>(
    out_ptr: R::ReprC,
) -> Result<R> {
    let mut store = Default::default();
    // NOTE: Bypasses the erroneous lifetime check.
    // Correct as long as `R::try_from_repr_c` doesn't return a reference to the store (`R: NonLocal`)
    let store_borrow = &mut *addr_of_mut!(store);
    CTypeConvert::try_from_repr_c(out_ptr, store_borrow)
}
